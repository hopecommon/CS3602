#!/usr/bin/env python3
"""
Generate Figure 1 (Option B): KV-cache length vs decode steps.

This script writes a self-contained TikZ/PGFPlots snippet (LaTeX) to avoid
Python plotting dependencies that may be fragile in restricted environments.

We visualize the difference between:
- Strict Start+Recent pruning (R=1): cache length stays at cap C_cap.
- Lazy Pruning (R>1): cache length grows to C_cap+(R-1) before pruning back.

The figure is derived from the paper result JSONs (for C_cap and R) and does
not require re-running any model inference.
"""

from __future__ import annotations

import argparse
import json
from pathlib import Path


def _load_json(path: Path) -> dict:
    with path.open("r", encoding="utf-8") as f:
        return json.load(f)


def _infer_cap_total(d: dict) -> int:
    cfg = d.get("streaming_llm") or {}
    cap = cfg.get("max_cache_size")
    if cap is not None:
        return int(cap)
    n_sink = int(cfg.get("n_sink", 0))
    window = int(cfg.get("window_size", 0))
    if n_sink > 0 and window > 0:
        return n_sink + window
    raise ValueError("Cannot infer cap total (missing max_cache_size or n_sink+window_size).")


def _infer_lazy_R(d: dict) -> int:
    cfg = d.get("streaming_llm") or {}
    R = cfg.get("compress_every")
    if R is None:
        raise ValueError("Cannot infer Lazy Pruning interval R (missing streaming_llm.compress_every).")
    return int(R)


def _build_series(*, cap: int, R: int, steps: int) -> tuple[list[int], list[int]]:
    """
    Build a synthetic KV-length series for Lazy pruning:
    start at cap, then grow by 1 per step; prune when overflow reaches R.

    We plot the cache length seen by the model forward (i.e., the length after
    appending the new token, right before pruning resets the cache). Under this
    convention, the sawtooth peaks at cap+R.
    """
    if steps <= 0:
        raise ValueError("steps must be positive")
    if R <= 0:
        raise ValueError("R must be positive")

    x = list(range(steps))
    period = R + 1
    y = [cap + (t % period) for t in x]
    return x, y


def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("--results-dir", type=Path, default=Path("results/paper_experiments"))
    ap.add_argument("--strict", type=str, default="pg19_start_recent.json")
    ap.add_argument("--lazy", type=str, default="pg19_ours.json")
    ap.add_argument("--steps", type=int, default=256)
    ap.add_argument("--out-tex", type=Path, default=Path("NeurIPS/generated/fig1_kv_length.tex"))
    args = ap.parse_args()

    strict_path = args.results_dir / args.strict
    lazy_path = args.results_dir / args.lazy
    strict = _load_json(strict_path)
    lazy = _load_json(lazy_path)

    cap = _infer_cap_total(strict)
    R = _infer_lazy_R(lazy)

    x = list(range(args.steps))
    y_strict = [cap] * args.steps
    x_lazy, y_lazy = _build_series(cap=cap, R=R, steps=args.steps)
    assert x_lazy == x

    args.out_tex.parent.mkdir(parents=True, exist_ok=True)

    def coords(xs, ys):
        return " ".join(f"({xi},{yi})" for xi, yi in zip(xs, ys))

    y_max = cap + max(10, R + 10)
    y_min = cap - 10

    tex = """
% Auto-generated by experiments/paper/generate_fig1_kv_length.py
\\begin{{tikzpicture}}
\\begin{{axis}}[
    width=\\linewidth,
    height=3.0cm,
    xlabel={{Decode step}},
    ylabel={{KV length (tokens)}},
    xmin=0, xmax={x_max},
    ymin={y_min}, ymax={y_max},
    grid=both,
    grid style={{line width=.1pt, draw=gray!20}},
    major grid style={{line width=.2pt,draw=gray!30}},
    legend style={{draw=none, fill=none, font=\\small}},
    legend pos=north east,
    tick label style={{font=\\small}},
    label style={{font=\\small}},
]
\\addplot+[thick] coordinates {{ {strict_coords} }};
\\addlegendentry{{Strict ($R=1$)}}
\\addplot+[thick] coordinates {{ {lazy_coords} }};
\\addlegendentry{{Lazy ($R={R}$)}}
\\addplot+[dashed] coordinates {{ (0,{cap}) ({x_max},{cap}) }};
\\node[anchor=west, font=\\small] at (axis cs:2,{cap_label_y}) {{$C_{{cap}}={cap}$}};
\\node[anchor=west, font=\\small] at (axis cs:2,{cap_r_label_y}) {{$C_{{cap}}+R={cap_r}$}};
\\end{{axis}}
\\end{{tikzpicture}}
""".lstrip().format(
        x_max=args.steps - 1,
        y_min=y_min,
        y_max=y_max,
        strict_coords=coords(x, y_strict),
        lazy_coords=coords(x, y_lazy),
        R=R,
        cap=cap,
        cap_label_y=cap + 2,
        cap_r_label_y=cap + R + 2,
        cap_r=cap + R,
    )

    args.out_tex.write_text(tex, encoding="utf-8")
    print(f"Wrote: {args.out_tex}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
